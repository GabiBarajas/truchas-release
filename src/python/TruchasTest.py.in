#!/usr/bin/env python

import os
import sys

import logging
import unittest

import Truchas

'''
Simple functions to query the 
executable, build and source directories.
'''
def get_executable_directory():
  return '@TruchasExe_BINARY_DIR@'

def get_executable():
  dir=get_executable_directory()
  return dir + os.path.sep + '@Truchas_EXECUTABLE@' 

def get_restart_executable():
  dir='@TruchasToolsPP_BINARY_DIR@' 
  return dir + os.path.sep + 'write_restart' 

def get_source_rootdir():
  return '@Truchas_SOURCE_DIR@'

def get_build_rootdir():
  return '@Truchas_BINARY_DIR@'

def get_test_source_rootdir():
  return '@TruchasTest_SOURCE_DIR@'

def get_test_build_rootdir():
  return '@TruchasTest_BINARY_DIR@'

def verify_directory(dir):
  try:
    os.stat(dir)
  except:
    try:
      os.makedirs(dir)
    except:
      raise TruchasIOError("Failed to create " + dir)

def verify_file(f):
  try:
    os.stat(f)
  except:
    raise TruchasIOError("Failed state the file " + f)

'''
Base Test Case Class
'''
class BaseTestCase(unittest.TestCase):

  '''Flag that the class has been initialized'''
  _is_initialized = False

  '''Truchas object'''
  truchas=None

  '''Flag for parallel builds'''
  truchas_is_parallel=None

  @classmethod
  def setUpClass(cls):
    cls.truchas_is_parallel=@ENABLE_MPI_FLAG@
    executable=get_executable() 
    cls.truchas=Truchas.SelectTruchasBinary(parallel=@ENABLE_MPI_FLAG@,filename=executable)
    cls.truchas.restart_executable=get_restart_executable()
    cls._is_initialized = True

  @classmethod
  def tearDownClass(cls):
    pass

  def setUp(self):
    if self._is_initialized is False:
      self.setUpClass()

  def tearDown(self):
    pass

  '''
  unittest ignores any method that does not begin with
  'test_' or 'runTest'
  '''
  def get_input_rootdir(self,test_name):
    return os.path.join(get_test_source_rootdir(),test_name)

  def get_output_rootdir(self,test_name):
    return os.path.join(get_test_build_rootdir(), test_name)

  def clean_output_directory(self,test_name,outdir):
    path=os.path.join(self.get_output_rootdir(test_name),outdir)
    for f in os.listdir(path):
      f_path=os.path.join(path,f)
      if os.path.isfile(f_path):
        os.unlink(f_path)

  def build_output_directory(self,test_name,outdir):
    path=os.path.join(self.get_output_rootdir(test_name),outdir)
    verify_directory(path)
    return path

  def build_output_filename(self,test_name,outdir,file):
    return self.get_output_rootdir(test_name) + \
	   os.path.sep + outdir + \
	   os.path.sep + file

