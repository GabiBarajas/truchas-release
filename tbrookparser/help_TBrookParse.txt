This is the companion help file for TBrookParse.py. 

The first half of this text file is for the impatient, examples are simply 
provided with succint descriptions. For further information head to the
'PREAMBLE' section. 

INVOCATION:

lava% python your_truchasdir/tools/scripts/TBrookParse.py
lava% python your_truchasdir/TBrookParse.py test.xml
lava% python your_truchasdir/TBrookParse.py -e 'command list' test.xml
lava% python your_truchasdir/TBrookParse.py -f commands.mac 

  The first form just brings up the command loop without loading any file. Typing
  'load' here will prompt the user to load in a default .xml file into memory. 
  The second form will load the file test.xml into memory.  Loading involves
  reading timestep data regarding what variables are available in what
  cycles.

  The third form executes the commands specified by 'command list'
  and exits, quotes are needed.  The fouth form executes commands 
  saved in file commands.mac and exits.

  For further macro file examples refer to 
  your_truchasdir/truchas/tools/scripts/test_TBrookParse/*.mac.

Once invoked, COMMANDS:

list of commands:
load , q[uit], e[nd], h[elp], write, restart, define, region, deleteAllRegions, query, stat[istics]

Command() load filename 
  Allows you to load a different file. You may load multiple files.

Command() list variables
  List variables and timestep information
  Note that you can also list regions and loaded files. For multiple
  loaded files, all variables associated with all files will be presented.

Command() list regions
  Provides a list of regions. Note that when an XML file is read by default a
  region named 'allMESH_i' associated with that file is created where i represents
  the mesh number in the file (in the majority of cases the XML file will only
  contain 1 mesh, in which case i=1). This default 
  region contains all CELL and VERTEX indices belonging to mesh i.   

Command() query outputfile screen P  allMESH_1 5 10
  Returns values of P for region 'allMESH_1' associated with XML file 'outputfile' 
  (automatically generated during the load process) for all cycles between 
  5 and 10 loaded from the outputfile 'outputfile' 
  (inclusive at both ends. i.e. [5,10]). The query will write the result to the screen.

Command() query outputfile file query.txt P allMESH_1 5 10
  Returns values of P for region 'allMESH_1' for all cycles between 5 and 10 
  loaded from the XML file 'outputfile' (inclusive at bot ends. i.e. [5,10]).
  The query will write the result to a file 'query.txt'.

Command() stat outputfile screen Velocity allMESH_1 0 10
  Provides statistics of all components of velocity and outputs these to the screen.
  The statistics are obtained by considering the data values in the region 'allMESH_1' 
  associated with the XML file 'outputfile' and
  include max, min, average, standard deviation and indices and positions where the min and max are
  located. They are provided for all cycles between and including 0 and 10.

Command() write gmv outputfile DefaultMesh 10 binary test.gmv all 
  Writes a binary gmv file for cycle 10 read from the outputfile 'outputfile'. 
  It outputs the mesh 'DefaultMesh' and 'all' variables that live on this mesh 
  into the file 'test.gmv'. 

Command() write gmv outputfile DefaultMesh  -1 ascii test.gmv "Density, Enthalpy" 
  Writes an ascii gmv file for all cycles read from the outputfile. 
  'outputfile'. It outputs the mesh 'DefaultMesh' and the variables 'Density' and 'Enthalpy' 
  that live on this mesh into files test.gmv.*  i.e. cycle 1 will have a gmv file
  test.gmv.000001, cycle 56 will be test.gmv.000056. Note that when instructing
  specific variables to be printed out, the variables must be seperated by a ',' and 
  enclosed by "".

Command() write ensight outputfile DefaultMesh -1 ascii truchas
  Writes an ascii ensight file for all cycles read from the outputfile 'outputfile'.
  It outputs the standard 'truchas' variables that live on 'DefaultMesh'. The output will be written 
  in the current directory producing a 'simulation_name.ensight.CASE' file and a
  'simulation_name.ensight' directory. Here 'simulation_name' is the name found in the 
  XML output file name, i.e outputfile = "simulation_name.TBrook.xml".

Command() write ensight outputfile DefaultMesh -1 ascii "Density, Enthalpy" 
  Writes an ascii ensight file for all cycles read from the outputfile 'outputfile'.
  It outputs the 'Density' and 'Enthalpy' variables that live on 'DefaultMesh'. 
  The output will be written in the current directory producing a 
  'simulation_name.ensight.CASE' file and a
  'simulation_name.ensight' directory. Here 'simulation_name' is the name found in the
  XML output file name, i.e outputfile = "simulation_name.TBrook.xml".

Command() restart outputfile standard DefaultMesh 10 binary test.restart
  Writes a standard (as opposed to a mapped restart) binary Truchas restart file, 'test.restart', for cycle 10, 
  relevant for mesh 'DefaultMesh' read from outputfile.

Command() restart outputfile mapped DefaultMesh 10 exofile csf binary test.restart
  Generates a binary Truchas restart file 'test.restart' by mapping data 
  from a previous Truchas simulation (data stored in the XML file 'outputfile' that lives on 
  its mesh 'DefaultMesh') at cycle 10 
  to a new mesh. This new mesh is read in from an Exodus file 'exofile'. 
  'outputfile' represents the XML file to map data from, 'mapped'
  signals to the postprocessor that the user would like to generate a restart file
  by mapping onto a new mesh, read in from an Exodus file 'exofile'. 'csf'
  is a mesh [c]ordinate [s]cale [f]actor - this is a scalar used to rescale the physical geometry 
  of the new input mesh (typically csf=1.0)

Command() restart outputfile1,outputfile2 mapped DefaultMesh,DefaultMesh 0 10 exofile csf binary test.restart
  Generates a binary Truchas restart file 'test.restart' by mapping data 
  from 2 previous Truchas simulations (data stored in the XML file 'outputfile1' that lives on 
  its mesh 'DefaultMesh' at cycle 0 and data stored in the XML file 'outputfile2' that lives on 
  its mesh 'DefaultMesh' at cycle 10) to a new mesh. This new mesh is read in from an Exodus file 'exofile'. 
  'outputfile1,outputfile2' represents the 2 XML files to map data from 
  (note the syntax here - there is no space between the commas), 'mapped'
  signals to the postprocessor that the user would like to generate a restart file
  by mapping onto a new mesh, read in from an Exodus file 'exofile'. 'csf'
  is a mesh [c]ordinate [s]cale [f]actor - this is a scalar used to rescale the physical geometry 
  of the new Exodus input mesh (typically csf=1.0). 

Command() restart outputfile1,outputfile2 standard DefaultMesh,DefaultMesh 10 20 binary test1.restart test2.restart
  Generates 2 standard binary Truchas restart files 'test1.restart' and 'test2.restart' by reading
  data from 2 previous Truchas simulations. 'test1.restart' is generated by reading data stored in the XML 
  file 'outputfile1' that lives on mesh 'DefaultMesh' at cycle 10. 'test2.restart' is generated by reading 
  data stored in the XML file 'outputfile2' that lives on mesh 'DefaultMesh' at cycle 20. 
  'outputfile1,outputfile2' represents the 2 XML files to read the data from 
  (note the syntax here - there is no space between the commas), 'standard'
  signals to the postprocessor that the user would like to generate 2 seperate restart files
  from the 2 Truchas simulations (as opposed to 'mapped' in the previous example).

Command() region outputfile R_02 DefaultMesh ID,VAR CELL 20-40 y 10 Enthalpy 0.5 1.0 y
  Defines region named 'R_02' read from outputfile using both the index 'ID' and variable 'VAR'
  selector criteria. As a result of the 'ID' selector, the region will contain 
  cells with indices in the range 20-40 (inclusive). As a result of the 'VAR' selector the
  region will also contain all cells where Enthalpy at cycle 10 is between 0.5 and 1.0.

Command() region outputfile R_03 DefaultMesh ID,S VERTEX 10-30 y [0.01,0.01,0.01]->[0.05,0.05,0.05] y
  Defines region named 'R_03' read from outputfile using both the index 'ID' and spatial 'S'
  selector criteria. As a result of the 'VERTEX' selector, the region will contain 
  vertices with indices in the range 10-30 (inclusive). As a result of the 'S selector the
  region will also contain all cells and vertices whose positions lie within the box-shaped 
  spatial domain [x1=0.01,y1=0.01,z1=0.01]->[x2=0.05,y2=0.05,z2=0.05].

Command() region outputfile byVF DefaultMesh VAR 10 V_Face 1 6 -200 200 y
  Defines region named 'byVF' read from outputfile as all vertices where the 1st component of 
  the velocity variable V_Face that lives on face 6 has a value in range [-200, 200] at cycle 10.  
  Note that the range is inclusive of both ends.

Notes:

You can specify multiple regions for multiple loaded files 
(i.e regions are not lost when you load a different file).
Regions are reflected in the GMV file under both 'groups' and 'flags'.

In mapping a Truchas simulation to a new Exodus mesh 
to create a restart, you will automatically create a 
new loaded file whose name is of the form
'simulationname__to__newmeshname'. During the postprocessing event, 
this loaded file will live in the 
directory where the original Truchas simulation output lives. 
An example macro file that creates such a restart is 
your_tdir/tools/scripts/test_TBrookParse/re_imvp.mac.

In mapping 2 Truchas simulations to a new Exodus mesh
to create a restart, you will automatically create a new loaded
file whose name is of the form
'simulation1name_simulation2name__to__newmeshname'.
During the postprocessing event, this loaded file will live in the
directory where the Exodus input mesh lives.
An example macro file that creates such a restart is 
your_truchasdir/tools/scripts/test_TBrookParse/re_mmab.mac

By typing the command:

Command() list files

straight after creating the mapped restart file you will see the
name and location of the newly loaded file. From this newly loaded file, you can then create 
GMV, Ensight files and create regions and query them as you would with a 
standard loaded Tbrook.xml file.  

For the more patient:

PREAMBLE: 
TBrookParse.py allows you to make sense of the XML output from Truchas.

It will read in multiple XML metafiles ( the simulationname.TBrook.xml file) and
process the data therein to produce GMV, Ensight or Truchas restart files. 
You may also define regions using combinations of the following selector criteria:

(1) ID specification; here the user provides a list or range of cell indices or vertex indices.
(2) VAR specification; here the user defines a region based on the data values of a 
particular variable at a particular cycle. 
(3) S specification; here the user provides a box-shaped spatial domain 
using the specification [x1,y1,z1]->[x2,y2,z2] (where [x1,y1,z1] is the point
closest to the origin and [x2,y2,z2] is the point furtherest from the origin).
The result will be a list of cell and vertex indices that lie within this spatial domain.
(4) MB specification; here the user provides an integer mesh block number which 
in turn provides a list of cells belonging to this mesh block number. This list
comes directly from data in the outputfile - if the outputfile does not contain any 
mesh block data then this specification cannot be used.

These regions are reflected in the GMV file under
'groups' and 'flags', so you can selectively draw different sets of
regions (Use the control key for selecting multiple regions within
gmv).  You can display statistics for a specific variable in a specific
region. Note however, if your defined region contains only cell (say) indices,
you can only query cell variables on that region - i.e you couldn't then try and
query a vertex variable on that region.

You may also use TBrookParse.py to map the results of a Truchas simulation to 
a different mesh in generating a restart file. To do this type the commands

Command() restart outputfile mapped
 
here outputfile is the name of the Truchas .TBrook.xml file and
'mapped' indicates that you want to create a restart on a different
Exodus II mesh - one to be specified by the user (by 'mapping' data to the new mesh). 
Once you have followed all the options
thereafter, you will then have a newly loaded file
'simulationname__to__newmeshname' at your disposal. 
This 'file' exists only during the postprocessing event and is 
'placed' in the directory where the Truchas .TBrook.xml file lives.
(Type 'list files' after you have created this mapped restart to
see the name and location of this newly formed file).
You can then create regions, query, stat
on these regions and create Ensight and GMV files 
from this newly loaded file in the same way
as done from the original .TBrook.xml file.

You may also use TBrookParse.py to map the results of 2 Truchas simulations to 
a different mesh in generating a restart file. To do this type the commands

Command() restart outputfile1,outputfile2 mapped
 
here outputfile1 and outputfile2 are the names of the 2 Truchas .TBrook.xml files and
'mapped' indicates that you want to create a restart on a different
Exodus II mesh - one to be specified by the user (by 'mapping' data to the new mesh). 
Once you have followed all the options
thereafter, you will then have a newly loaded file
'simulationname1_simulationname2__to__newmeshname' at your disposal. 
This 'file' exists only during the postprocessing event and is 
'placed' in the directory where the input Exodus II file lives.
(Type 'list files' after you have created this mapped restart to
see the name and location of this newly formed file).
You can then create regions, query, stat
on these regions and create Ensight and GMV files 
from this newly loaded file in the same way
as done from the original .TBrook.xml files.

As part of this mapping procedure a user can choose what variables to map and how
by editing the 'defaultmaps.txt' file located at

  your_truchasdir/truchas/tools/PythonPackages/TBrookParser/MODutils/MAPutils/defaultmaps.txt

Only those field variables listed in this file will be mapped, all other field variables will be  
set to default values. 
 
INVOCATION:
You can invoke the parser with one of the following forms:

python your_truchasdir/tools/scripts/TBrookParse.py
python your_truchasdir/tools/scripts/TBrookParse.py somedir/simulation_name.TBrook.xml
python your_truchasdir/tools/scripts/TBrookParse.py -e 'load somedir/simulation_name.TBrook.xml write gmv - - - - - -'
python your_truchasdir/tools/scripts/TBrookParse.py -f commands.mac 

The first one just brings up the command loop without loading any file. Typing
'load' here will prompt the user to load in a default .TBrook.xml file into memory.
The second form loads the file into memory
The third form executes the commands specified by the -e argument
The final form executes commands stored in file commands.mac. Note that comments
can be placed in this *.mac file after the 'q'.

For the third and fourth forms the parser will quit after executing
the specified commands. To begin we recommend the user employs the second form.
Once comfortable with the interface we recommend the user employs the
fourth form for efficiency. 

INTERFACE:
The interface is a prompt driven using a clone of usubs routines. 
The usubs routines were a set of routines written by Art Voter of T12 as
an interface to his code ClsMan (Cluster Manipulator).  I liked it so
much that I decided to use it as the interface for the postprocessor.

Basically, the entire command loop is 'prompt' driven.  What this
means is that you are presented by a prompt at every turn.  The
prompts contain appropriate choices, and some error checking
is done on the return values.  Further, all prompts will provide you
with a reasonable default value that will be accepted if you type a
return or a single minus sign (-).  

Further, you can 'type ahead'.  So, if you know what prompts are
coming up, and their default values or the values you want, you can
type commands ahead of time and you will not be presented with a
prompt for those values.  Here is an example of listing regions.  The
first command is list followed by regions:

*1:  Command:() list
  List what (files/regions/variables):(regions) regions
 
    Regions are:

       allMESH_1            : defined for problem.TBrook.xml on mesh DefaultMesh (i.e mesh 1) as ['CELL','FACE','VERTEX'](s) with all indices defined. 

*2: Command:() list regions
 
    Regions are:

       allMESH_1            : defined for problem.TBrook.xml on mesh DefaultMesh (i.e mesh 1) as ['CELL','FACE','VERTEX'](s) with all indices defined. 

*3: Command:() list -
 
    Regions are:

       allMESH_1            : defined for problem.TBrook.xml on mesh DefaultMesh (i.e mesh 1) as ['CELL','FACE','VERTEX'](s) with all indices defined. 

*4: Command:() list files
    
    Loaded files are:
             somedir/simulation_name.TBrook.xml 
             somedir/simulation_name_to_exofile 
   

Note that the prompt for 'list what...' was not displayed in *2 and
*3.  Also note that *3 uses the default value for list what.  


COMMANDS:
Commands are:
load , q[uit], e[nd], h[elp], list, region, write, restart, deleteAllRegions, query, stat[istics]

We will look at each of these in detail:

load filename:

   Loads a file and analyzes the time steps.  You can also specify a
   load file on invocation as shown in INVOCATION above.  

q,quit,e,end:

   Quit the parser


list  files | regions | variables :

   A command to list files, variables or regions that have been defined so
   far.  

   Here is an example:

     Command:() list regions

        Regions are:

	   allMESH_1	: defined for problem.TBrook.xml on mesh DefaultMesh (i.e mesh 1) as ['CELL','FACE','VERTEX'](s) with all indices defined. 

	   R_01         : defined for problem.TBrook.xml on mesh DefaultMesh as CELL(s) with IDs: 142
	   R_01         : defined for problem.TBrook.xml on mesh DefaultMesh as CELL(s) with Z_ENTHALPY between 4.050e+05 and 60000

           R_02         : defined for problem.TBrook.xml on mesh DefaultMesh as CELL(s) with V_Face_1_6 between 0.0 and 5.0  
	   R_02         : defined for problem.TBrook.xml on mesh DefaultMesh as ['CELL', 'FACE', 'VERTEX'](s) with spatial domain: [0.01,0.01,0.01]->[0.05,0.05,0.05]

region (or define):

   Defines regions which are sets of cells and/or vertices that satisfy certain
   criteria.  Currently you can define regions using combinations of the following selector criteria:
   (1) ID specification; here the user provides a list or range of cell indices or vertex indices.
   (2) VAR specification; here the user defines a region based on the data values of a 
   particular variable at a particular cycle. 
   (3) S specification; here the user provides a box-shaped spatial domain 
   using the specification [x1,y1,z1]->[x2,y2,z2] (where [x1,y1,z1] is the point
   closest to the origin and [x2,y2,z2] is the point furtherest from the origin).
   The result will be a list of cell and vertex indices that lie within this spatial domain.
   (4) MB specification; here the user provides an integer mesh block number which 
   in turn provides a list of cells belonging to this mesh block number. This list
   comes directly from data in the outputfile - if the outputfile does not contain any 
   mesh block data then this specification cannot be used.

   In the example above, we have previously defined the 3 regions,
 
      *'allMESH_1'     defined by default when we load in the problem.TBrook.xml file; 
		       contains all cell and vertex indices on the DefaultMesh

      *'R_01'          user defined using a combination of ID and VAR specifications; 
		       contains cell indice 142 and all cell indices on the DefaultMesh that have 4.050e+05 <= Enthalpy <= 60000  

      *'R_02'          user defined using a combination of the VAR and S specifications;
                       contains all cells on the DefaultMesh where the 
                       1st component of V_Face that lives on face 6 is between 0.0 and 5.0
		       and all cell and vertex indices that live within the box-shaped domain [0.01,0.01,0.01]->[0.05,0.05,0.05]

   Here are a couple examples:

      Command() region outputfile R_02 DefaultMesh ID,VAR CELL 20-40 y 10 P 0.5 1.0 y
      Defines region named 'R_02' read from outputfile using both the index 'ID' and variable 'VAR'
      selector criteria. As a result of the 'ID' selector, the region will contain 
      cells with indices in the range 20-40 (inclusive). As a result of the 'VAR' selector the
      region will also contain all cells where P at cycle 10 is between 0.5 and 1.0.

      Command() region outputfile R_03 DefaultMesh ID,S VERTEX 10-30 y [0.01,0.01,0.01]->[0.05,0.05,0.05] y
      Defines region named 'R_03' read from outputfile using both the index 'ID' and spatial 'S'
      selector criteria. As a result of the 'VERTEX' selector, the region will contain 
      vertices with indices in the range 10-30 (inclusive). As a result of the 'S selector the
      region will also contain all cells and vertices whose positions lie within the box-shaped 
      spatial domain [x1=0.01,y1=0.01,z1=0.01]->[x2=0.05,y2=0.05,z2=0.05].

      Command() region outputfile byVF DefaultMesh VAR 10 V_Face 1 6 -200 200 y
      Defines region named 'byVF' read from outputfile as all vertices where the 1st component of 
      the velocity variable V_Face that lives on face 6 has a value in range [-200, 200] at cycle 10.  
      Note that the range is inclusive of both ends.

      Hence, having defined these regions, the following output results when we list them	

      Command:() list regions

      Regions are:

      allMESH_1           : defined for outputfile on mesh DefaultMesh as ['CELL', 'FACE', 'VERTEX'](s) with all indices defined

       R_02               : defined for outputfile on mesh DefaultMesh as CELL(s) with IDs: 20-40
       R_02               : defined for outputfile on mesh DefaultMesh as CELL(s) with Z_P between 0.5 and 1.0

       R_03               : defined for outputfile on mesh DefaultMesh as VERTEX(s) with IDs: 10-30	
       R_03               : defined for outputfile on mesh DefaultMesh as ['CELL', 'FACE', 'VERTEX'](s) with spatial domain: [0.01,0.01,0.01]->[0.05,0.05,0.05]

       byVF               : defined for outputfile on mesh DefaultMesh as CELL(s) with Z_VF_1_6 between -200 and 200

 query

  query a variable by region.  In the following example we print the
  value of P read from outputfile in region 'R_02' for low cycle number = 1 
  and high cycle number = 1 to the screen

     Command:() query outputfile screen P R_02 1 1


------------------------------------------------------------------------------------------
       VAR                 TIME                     CYCLE
        P                  0.000                       0 
------------------------------------------------------------------------------------------
     Index             Position                  Value(s)
        1       [  2.50,   5.00,   5.00]       1.000e+00
        2       [  7.50,   5.00,   5.00]       1.000e+00
        3       [ 12.50,   5.00,   5.00]       1.000e+00


     When querying a vector field (such as Velocity) all components of the vector field are presented

     Command:() query outputfile screen Velocity R_01 - -


------------------------------------------------------------------------------------------
       VAR                 TIME                     CYCLE
    Velocity              0.000                       0 
------------------------------------------------------------------------------------------
     Index             Position                  Value(s)
        1       [  2.50,   5.00,   5.00]       (  6.073e-03 -6.035e-03  0.000e+00     ) 
        2       [  7.50,   5.00,   5.00]       (  6.073e-03 -6.035e-03  0.000e+00     ) 
        3       [ 12.50,   5.00,   5.00]       (  6.073e-03 -6.035e-03  0.000e+00     ) 


statistics, stat

   Present statistics on a variable by region.  The statistics include max, min, average, standard deviation and 
   indices and positions indicating where the min and max are located. In the following
   example we present statistics for del-rho read from outputfile in the region defined 
   as 'R_01' for cycles 0 to 1. del-rho is a scalar so it has only 1 component ('COMP'). 
   The statistics are printed to the screen.

    Command() stat outputfile screen del-rho R_01 0 1

------------------------------------------------------------------------------------------
                              TIME:    0.000        CYCLE:        0
------------------------------------------------------------------------------------------
   COMP        AVG         MIN		MIN_at (Index,Posn)       MAX        MAX_at (Index,Posn)     STDEV
    1    0.000e+00   0.000e+00        1 [0.0,0.0,0.0]         0.000e+00        1 [0.0,0.0,0.0]	 0.000e+00


------------------------------------------------------------------------------------------
                              TIME:    0.100        CYCLE:        1
------------------------------------------------------------------------------------------
   COMP        AVG         MIN		MIN_at (Index,Posn)       MAX        MAX_at (Index,Posn)     STDEV
    1    0.000e+00   0.000e+00        1 [0.0,0.0,0.0]         0.000e+00        1 [0.0,0.0,0.0]	 0.000e+00


   Note that

     Command() stat outputfile file query.txt del-rho  R_01 0 1

     produces the same results as the example above printed to a file named 'query.txt'.

   Statistics for a vector field (such as Velocity) are presented for all components of the vector field
   as shown below

    Command() stat outputfile screen Velocity R_01 0 0

------------------------------------------------------------------------------------------
                              TIME:    0.000        CYCLE:        0
------------------------------------------------------------------------------------------
    COMP        AVG         MIN		MIN_at (Index,Posn)       MAX        MAX_at (Index,Posn)     STDEV
       1    0.000e+00   0.000e+00        1 [0.0,0.0,0.0]     0.000e+00        1	[0.0,0.0,0.0]	 0.000e+00
       2    0.000e+00   0.000e+00        1 [0.0,0.0,0.0]     0.000e+00        1	[0.0,0.0,0.0]	 0.000e+00
       3    0.000e+00   0.000e+00        1 [0.0,0.0,0.0]     0.000e+00        1	[0.0,0.0,0.0]	 0.000e+00

write gmv 
   Writes gmv files.  For these files, you can define a
   new TBrook file to write from, you can choose what field variables you want written 
   to the gmv file(s), the root name for the files, and which
   cycles to write the file for.  Note that you can either write one
   cycle or all of them.  Currently there is no way to select a few
   cycles, but this will be incorporated soon.  

   Here are two examples:

   Command() write gmv outputfile DefaultMesh 10 binary test.gmv all 
      Writes a binary gmv file for cycle 10 read from outputfile. 
      It outputs the mesh 'DefaultMesh' and 'all' variables that live on this mesh 
      into the file 'test.gmv'. 

   Command() write gmv outputfile DefaultMesh -1 ascii test.gmv "Density, Enthalpy"
      Writes an ascii gmv file for all cycles read from the outputfile. 
      'outputfile'. It outputs the mesh 'DefaultMesh' and the variables 
      'Density' and 'Enthalpy' that live on this mesh 
      into files test.gmv.*  i.e. cycle 1 will have a gmv file
      test.gmv.000001, cycle 56 will be test.gmv.000056. Note that when instructing
      specific variables to be printed out, the variables must be seperated by a ',' and 
      enclosed by "". 

write ensight

   Writes ensight files. For these files, you can define a
   new TBrook file to write from, you can choose what field variables you want written 
   to the ensight file(s), the root for the files and which
   cycles to write the file for. Note that you can either write one
   cycle or all of them.  Currently there is no way to select a few
   cycles, but this will be incorporated soon. The ensight output will
   be produced in the current directory, a 'simulation_name.ensight.CASE'
   and a 'simulation_name.ensight' directory will be produced. Here
   'simulation_name' is automatically derived from the name of your TBrook.xml file
   you are interrogating, i.e the TBrook filename is 
   'simulation_name.TBrook.xml'.

restart

   Writes standard and mapped Truchas restart files. 

   As with writing GMV files, you can write standard Truchas restart files 
   by defining a new .TBrook.xml file to write from, the root for the files, and which
   cycles to write the file for. Note that you can either write one
   cycle or all of them. Restart files are always written in binary mode.

   We can also generate a restart file by mapping either one or two Truchas simulations to a 
   new Exodus II mesh. 

   In mapping one Truchas simulation to a new mesh, the postprocessor will 
   automatically create a new loaded file whose name is of the form
   'simulationname__to__newmeshname'. This file exists only during the postprocessing event,
   the postprocessor places it in the directory where the orignal Truchas .TBrook.xml file 
   lives. For now you must specify a particular cycle which contains data to be mapped to
   a new mesh.

   In mapping two Truchas simulations to a new mesh, the postprocessor will 
   automatically create a new loaded file whose name is of the form
   'simulation1name_simulation2name__to__newmeshname'. This file exists only 
   during the postprocessing event, the postprocessor places it in the directory where 
   the Exodus II file lives. 
   
   You can check this by typing the command:

        Command() list files

   straight after creating the mapped restart file - you will see the
   newly loaded file is listed. From this newly loaded file, you can then create 
   GMV, Ensight files and create regions and query them as you would with a standard loaded file.  
   Note that the mesh name in this newly mapped file is denoted as 'ExoMesh' (instead of 
   'DefaultMesh'). (You could even create a standard restart file from this newly formed file
   using the same set of commands used to create a standard restart from a .TBrook.xml file).

   For the case of mapping one Truchas simulation to one Exodus II mesh, 
   the only cycles that will exist in this newly mapped file are those
   in the Truchas simulation you requested to restart from. 
   
   For the case of mapping two Truchas simulations to one Exodus II mesh, cycles in the 
   newly mapped file are simply numbered sequentially (this number represents the
   number of times in the given postprocessing event you have requested to map the 
   given two Truchas simulations to the given Exodus II mesh).

   Here are some examples:

   Command() restart outputfile standard DefaultMesh 10 binary test.restart
      Writes a standard truchas binary restart file, 'test.restart', for cycle 10, relevant for mesh 'DefaultMesh' 
      by reading data from outputfile.

   Command() restart outputfile mapped DefaultMesh 10 exofile csf binary test.restart
      Generates a binary Truchas restart file 'test.restart' by mapping data 
      from a previous Truchas simulation (data stored in the XML file 'outputfile' that lives on 
      its mesh 'DefaultMesh') at cycle 10 
      to a new mesh. This new mesh is read in from an Exodus II file 'exofile'. 
      'outputfile' represents the XML file to map data from, 'mapped'
      signals to the postprocessor that the user would like to generate a restart file
      by mapping onto a new mesh, read in from an Exodus II file 'exofile'. 'csf'
      is a mesh [c]ordinate [s]cale [f]actor - this is a scalar used to rescale the physical geometry 
      of the new input mesh (typically csf=1.0)

   Command() restart outputfile1,outputfile2 mapped DefaultMesh,DefaultMesh 0 10 exofile csf binary test.restart
      Generates a binary Truchas restart file 'test.restart' by mapping data 
      from 2 previous Truchas simulations (data stored in the XML file 'outputfile1' that lives on 
      its mesh 'DefaultMesh' at cycle 0 and data stored in the XML file 'outputfile2' that lives on 
      its mesh 'DefaultMesh' at cycle 10) to a new mesh. This new mesh is read in from an Exodus file 'exofile'. 
      'outputfile1,outputfile2' represents the 2 XML files to map data from 
      (note the syntax here - there is no space between the commas), 'mapped'
      signals to the postprocessor that the user would like to generate a restart file
      by mapping onto a new mesh, read in from an Exodus II file 'exofile'. 'csf'
      is a mesh [c]ordinate [s]cale [f]actor - this is a scalar used to rescale the physical geometry 
      of the new Exodus input mesh (typically csf=1.0).

   You may also choose to create two standard restart files by specifying two Truchas simulations and their 
   meshes and cycle numbers as input. An example is below   

   Command() restart outputfile1,outputfile2 standard DefaultMesh,DefaultMesh 10 20 binary test1.restart test2.restart
      Generates 2 standard binary Truchas restart files 'test1.restart' and 'test2.restart' by reading
      data from 2 previous Truchas simulations. 'test1.restart' is generated by reading data stored in the XML 
      file 'outputfile1' that lives on mesh 'DefaultMesh' at cycle 10. 'test2.restart' is generated by reading 
      data stored in the XML file 'outputfile2' that lives on mesh 'DefaultMesh' at cycle 20. 
      'outputfile1,outputfile2' represents the 2 XML files to read the data from 
      (again note the syntax here - there is no space between the commas), 'standard'
      signals to the postprocessor that the user would like to generate 2 seperate restart files
      from the 2 Truchas simulations (as opposed to 'mapped' in the previous example). 

All the example commands so far have been written on the command line but it
is typically more efficient to store your commands in a file 'commands.mac'.
Invoking the command:

   python TBrookParse.py -f commands.mac 

will then execute all the commands in commands.mac without user interactivity.
An example commands.mac file which generates standard restarts from cycle 13 read from 
file test.xml is provided below

restart
test.xml
standard
DefaultMesh
13
binary
test.restart
q

Refer to tools/scripts/test_TBrookParse/samples/*.mac for more examples.

In particular two extensive examples for testing the 'mapped' option in the restart option are  

(1) tools/scripts/test_TBrookParse/re_imem.mac
(2) tools/scripts/test_TBrookParse/re_mmab.mac 

(1) provides an example of generating a restart file, 'reimem.0', from the em_restart problem by mapping the
fields at cycle 4 to the 'quart-cyl-hex.exo' mesh file. As a result of this mapping the postprocessor creates
a newly loaded file, em_restarts2__to__quart-cyl-hex and writes GMV and EnSight files from this file.
(2) provides an example of generating a binary restart file, 'remmab.0', by mapping data from 2 Truchas simulations 
'map.TBrook.xml' (at cycle 0) and 'map-b.TBrook.xml' (at cycle 10) to an Exodus II mesh ('mesh-ab_f.exo') 
As a result of this mapping the postprocessor creates a newly loaded file, 
'map_map-b__to__mesh-ab_f' is created from which a region is specified and queried and a GMV plot is created.
It is a worthwhile exercise to use the postprocessor interactively and repeat the commands in both these *.mac files
to become familiar with this new mapping capability.

To begin with, I strongly suggest referring to this file and the example *.mac files 
while using the postprocessor interactively so you can get a feel for the new capabilities within it.
    
--end--
We will add to this file as time goes by.
--Sriram and Sharen
